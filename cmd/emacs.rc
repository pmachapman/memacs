;	EMACS.RC:	Standard MicroEMACS Startup program
;			for MicroEMACS 3.13 and above
;			(C)opyright 1987-99 by Daniel M Lawrence
;			Last Update: 11/13/93

set $discmd FALSE
write-message "[Setting up....]"

; If you screen "SNOWS", comment this line
	set $flicker "FALSE"

; To use an IBM-PC EGA card, uncomment the following line
;	set $sres "EGA"

;	If you hate clocks or position counters, comment these
;set $timeflag TRUE
set $posflag TRUE
set $sscroll TRUE

;	Set Default Global modes

add-global-mode "white"
add-global-mode "BLACK"
;bind-to-key meta-prefix `	;for annoying keyboards with ` at the top left

;	Toggle function key window display

store-procedure toggle-fkeys
	!if %rcfkeys
		!goto rcfoff
	!endif

;	toggle function key window on
	save-window
	1 next-window
	!if &sequal $cbufname "emacs.hlp"
		delete-window
	!endif
	!if &not &sequal $cbufname "[Function Keys]"
		1 split-current-window
		1 select-buffer "[Function Keys]"
		add-mode "blue"
		add-mode "WHITE"
		!force 5 resize-window
		1 goto-line
	!endif
	set %rcfkeys TRUE
	!force restore-window
	!if &sequal $cbufname "[Function Keys]"
		next-window
	!endif
	write-message "[Function key window ON]"
	!return

	;Toggle the function key window off
*rcfoff
	save-window
	1 next-window
	!if &sequal "[Function Keys]" $cbufname
		delete-window
	!endif
	!force restore-window
	write-message "[Function key window OFF]"
	set %rcfkeys FALSE
!endm

;	Bring up Online-help system

store-procedure get-help
	set $discmd FALSE
	source ehelp.cmd
	set $discmd TRUE
!endm

;	Load a new page

store-procedure get-page-loader
	!if &seq &find newpage.cmd ""
		write-message "[Can not find NEWPAGE.CMD]"
		!return
	!endif
	execute-file newpage.cmd
!endm

;procedure to clean out the current page (which is nothing right now)

store-procedure clean
	; nothing by default
!endm

;	Set up auto CMODE

store-procedure set-default-mode
	set %rctmp &sin $cfname "."
	!if &equ %rctmp 0
		!return
	!endif
	!if &seq $os "THEOS"
		set %rctmp &mid $cfname &add %rctmp 1 2
		!if &or &seq %rctmp "c:" &seq %rctmp "h:"
			add-mode "cmode"
		!endif
		set %rctmp &mid $cfname &add %rctmp 1 4
		!if &or &seq %rctmp "cpp:" &seq %rctmp "hpp:"
			add-mode "cmode"
		!endif
		!if &seq %rctmp "txt:"
			add-mode "wrap"
		!endif
	!else
		set %rctmp &mid $cfname &add %rctmp 1 5
		!if &or &seq %rctmp "c" &seq %rctmp "h"
			add-mode "cmode"
		!endif
		!if &or &seq %rctmp "cpp" &seq %rctmp "hpp"
			add-mode "cmode"
		!endif
		!if &or &seq %rctmp "mss" &seq %rctmp "txt"
			add-mode "wrap"
		!endif
	!endif
!endm
set $readhook set-default-mode

;	This function activates the function key window as
;	a legitimate place to call up function keys using the mouse

store-procedure mouse-clicks

	;remember where we started, and do the mouse movement
	save-window
	!force mouse-move-down

	;If not in the function key window... leave
	!if &not &sequal $cbufname "[Function Keys]"
		!return
	!endif

	;First pos is a screen reposition, let it through
	!if &and &equ $xpos 0 &equ $ypos 0
		restore-window
		!return
	!endif

	;Find out what function key were gonna do
	add-mode magic
	2 forward-character
	set %rctmp $search
	!force search-reverse "[fF][0-9]"
	!if &seq $status FALSE
		delete-mode magic
		set $search %rctmp
		!return
	!endif

	;we are on the "f" or "F".  Get the function key type and number now
	set $search %rctmp
	set %fcase lower
	!if &equ $curchar 70
		set %fcase upper
	!endif
	1 forward-character
	set %fnum &chr $curchar
	1 forward-character
	set %fnum &cat %fnum &chr $curchar
	set %fnum &add %fnum 0
	!if &equ %fnum 10
		set %fnum "0"
	!endif
	set %fname &cat "FN" %fnum
	!if &seq %fcase upper
		set %fname &cat "S-" %fname
	!endif

	;save the function
	set %rccmd &bind %fname
	delete-mode MAGIC

	;swallow the up-button
	set %rctmp &gtc

	;restore the window and exit
	restore-window

	;procedures don't need the square brackets
	!if &seq &left %rccmd 1 "["
		set %rccmd &mid %rccmd 2 &sub &len %rccmd 2
		%rccmd
		!return
	!endif

	;and then execute it
	!force execute-named-command %rccmd
!endm   
macro-to-key mouse-clicks MSa

;	***** Rebind the Function key group

bind-to-key search-forward		FN1
bind-to-key search-reverse		FN2
bind-to-key hunt-forward		FN3
bind-to-key hunt-backward		FN4
macro-to-key toggle-fkeys		FN5
macro-to-key get-help			FN6
bind-to-key next-window 		FN7
macro-to-key get-page-loader		FN8
bind-to-key exit-emacs			FN9
bind-to-key save-file			FN0

bind-to-key move-window-up		FN^P
bind-to-key move-window-down		FN^N
bind-to-key scroll-next-up		M-FNZ
bind-to-key scroll-next-down		M-FNV

!if &seq $os "UNIX"
	bind-to-key delete-next-character	^?
	bind-to-key delete-next-word		M-^?
	bind-to-key delete-previous-word	M-^H
!else
	bind-to-key delete-previous-character	^?
	bind-to-key delete-previous-word	M-^?
	bind-to-key delete-next-word		M-FND
!endif

;	bring up the function key window

	1 split-current-window
	1 select-buffer "[Function Keys]"
	insert-string "f1 search-> f2 <-search |    MicroEMACS:  Text Editor~n"
	insert-string "f3 hunt->   f4 <-hunt   | ~n"
	insert-string "f5 fkeys    f6 help     |  Available function key Pages include:~n"
	insert-string "f7 nxt wind f8 pg[    ] |    Word  Box  Emacs  Pascal  C  cObol Lisp~n"
	insert-string "f9 exit    f10 save     |  [use the f8 key to load Pages]~n"
	unmark-buffer
	delete-window
	set %rcfkeys FALSE

	!if &seq $os "unix"

		;Allow mainframes to simulate function
		;keys with ^C<n> and ^C shifted-<n>
		
		store-procedure emulate-fkeys
			!if &not $pending
				write-message "FN-"
			!endif
			set %rcchar &gtkey
			set %rcchar &sindex "1234567890!@#$%^&*()" %rcchar
			!if &equ %rcchar 0
				write-message "[Not Bound]"
				!return
			!endif
			clear-message-line
			set %rctmp "FN"
			!if &gre %rcchar 10
				set %rctmp &cat "S-" %rctmp
			!endif
			set %rcchar &mid "12345678901234567890" %rcchar 1
			set %rctmp &bind &cat %rctmp %rcchar
			!if &seq &lef %rctmp 1 "["
				set %rctmp &mid %rctmp 2 &sub &len %rctmp 2
				run %rctmp
				!return
			!endif
			!force execute-named-command %rctmp
		!endm

		macro-to-key emulate-fkeys ^C
		
	!endif

	!if &seq $os "MSWIN"
		source "mewin.cmd"
	!else
		toggle-fkeys
	!endif

!if &seq $os "OS2"
	set $sres VGA
	set $sres CGA
!endif

store-procedure toggle-insert
	!if &gre &mod $cmode 64 31
		delete-mode "over"
	!else
		add-mode "over"
	!endif
!endm
macro-to-key toggle-insert	FNC

store-procedure single-graphics
	!force delete-mode "GRD"
	add-mode "GRS"
!endm
macro-to-key single-graphics	FN-

store-procedure double-graphics
	!force delete-mode "GRS"
	add-mode "GRD"
!endm
macro-to-key double-graphics	S-FN-

store-procedure no-graphics
	!force add-mode "GRS"
	!force add-mode "GRD"
!endm
macro-to-key no-graphics	FN^-

set $discmd TRUE
